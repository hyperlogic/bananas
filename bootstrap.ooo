;
; version number and date
;
;; ($set-version (0.0 3)
;;               (0.1 2))
;; ($set-revision-date 2009 8 30)

;
; derived core features
;   derivations are as in the R-1RK, not chosen for efficiency
;

;; previously defined in obj_init()
;; ($define! $sequence
;;    ((wrap ($vau ($seq2) #ignore
;;              ($seq2
;;                 ($define! $aux
;;                    ($vau (head . tail) env
;;                       ($if (null? tail)
;;                            (eval head env)
;;                            ($seq2
;;                               (eval head env)
;;                               (eval (cons $aux tail) env)))))
;;                 ($vau body env
;;                    ($if (null? body)
;;                         #inert
;;                         (eval (cons $aux body) env))))))
;;
;;       ($vau (first second) env
;;          ((wrap ($vau #ignore #ignore (eval second env)))
;;           (eval first env)))))

($define! list (wrap ($vau x #ignore x)))

($define! list*
   (wrap ($vau args #ignore
            ($sequence
               ($define! aux
                  (wrap ($vau ((head . tail)) #ignore
                           ($if (null? tail)
                                head
                                (cons head (aux tail))))))
               (aux args)))))

($define! $vau
   ((wrap ($vau ($vau) #ignore
             ($vau (formals eformal . body) env
                (eval (list $vau formals eformal
                           (cons $sequence body))
                      env))))
      $vau))

($define! $lambda
   ($vau (formals . body) env
      (wrap (eval (list* $vau formals #ignore body)
                  env))))

($define! car ($lambda ((x . #ignore)) x))
($define! cdr ($lambda ((#ignore . x)) x))

($define! caar ($lambda (((x . #ignore) . #ignore)) x))
($define! cdar ($lambda (((#ignore . x) . #ignore)) x))
($define! cadr ($lambda ((#ignore . (x . #ignore))) x))
($define! cddr ($lambda ((#ignore . (#ignore . x))) x))

($define! caaar ($lambda ((((x . #ignore) . #ignore) . #ignore)) x))
($define! cdaar ($lambda ((((#ignore . x) . #ignore) . #ignore)) x))
($define! cadar ($lambda (((#ignore . (x . #ignore)) . #ignore)) x))
($define! cddar ($lambda (((#ignore . (#ignore . x)) . #ignore)) x))
($define! caadr ($lambda ((#ignore . ((x . #ignore) . #ignore))) x))
($define! cdadr ($lambda ((#ignore . ((#ignore . x) . #ignore))) x))
($define! caddr ($lambda ((#ignore . (#ignore . (x . #ignore)))) x))
($define! cdddr ($lambda ((#ignore . (#ignore . (#ignore . x)))) x))

($define! caaaar ($lambda (((((x . #ignore) . #ignore) . #ignore). #ignore))x))
($define! cdaaar ($lambda (((((#ignore . x) . #ignore) . #ignore). #ignore))x))
($define! cadaar ($lambda ((((#ignore . (x . #ignore)) . #ignore). #ignore))x))
($define! cddaar ($lambda ((((#ignore . (#ignore . x)) . #ignore). #ignore))x))
($define! caadar ($lambda (((#ignore . ((x . #ignore) . #ignore)). #ignore))x))
($define! cdadar ($lambda (((#ignore . ((#ignore . x) . #ignore)). #ignore))x))
($define! caddar ($lambda (((#ignore . (#ignore . (x . #ignore))). #ignore))x))
($define! cdddar ($lambda (((#ignore . (#ignore . (#ignore . x))). #ignore))x))
($define! caaadr ($lambda ((#ignore .(((x . #ignore) . #ignore) . #ignore)))x))
($define! cdaadr ($lambda ((#ignore .(((#ignore . x) . #ignore) . #ignore)))x))
($define! cadadr ($lambda ((#ignore .((#ignore . (x . #ignore)) . #ignore)))x))
($define! cddadr ($lambda ((#ignore .((#ignore . (#ignore . x)) . #ignore)))x))
($define! caaddr ($lambda ((#ignore .(#ignore . ((x . #ignore) . #ignore))))x))
($define! cdaddr ($lambda ((#ignore .(#ignore . ((#ignore . x) . #ignore))))x))
($define! cadddr ($lambda ((#ignore .(#ignore . (#ignore . (x . #ignore)))))x))
($define! cddddr ($lambda ((#ignore .(#ignore . (#ignore . (#ignore . x)))))x))

($define! apply
   ($lambda (appv arg . opt)
      (eval (cons (unwrap appv) arg)
            ($if (null? opt)
                 (make-environment)
                 (car opt)))))

($define! $cond
   ($vau clauses env

      ($define! aux
         ($lambda ((test . body) . clauses)
            ($if (eval test env)
                 (apply (wrap $sequence) body env)
                 (apply (wrap $cond) clauses env))))

      ($if (null? clauses)
           #inert
           (apply aux clauses))))

($define! get-list-metrics
   ($lambda (ls)

      ($define! aux
         ($lambda (kth k nth n)
            ($if (>=? k n)
                 ($if (pair? (cdr nth))
                      (aux ls 0 (cdr nth) (+ n 1))
                      (list (+ n 1)
                            ($if (null? (cdr nth)) 1 0)
                            (+ n 1)
                            0))
                 ($if (eq? kth nth)
                      (list n 0 k (- n k))
                      (aux (cdr kth) (+ k 1) nth n)))))

      ($if (pair? ls)
           (aux ls 0 ls 0)
           (list 0 ($if (null? ls) 1 0) 0 0))))

($define! list-tail
   ($lambda (ls k)
      ($if (>? k 0)
           (list-tail (cdr ls) (- k 1))
           ls)))

($define! encycle!
   ($lambda (ls k1 k2)
      ($if (>? k2 0)
           (set-cdr! (list-tail ls (+ k1 k2 -1))
                     (list-tail ls k1))
           #inert)))

;
; digression:
;   math applicatives max and lcm are used by map, so must be provided
;   to test map, and without using anything derived later than map
;

($define! max
   ($lambda x

      ($define! aux
         ($lambda (count result . x)
            ($if (<=? count 0)
                 result
                 ($sequence
                    ($if (>? (car x) result)
                         ($define! result ($if (inexact? result)
                                               (* (car x) 1.0)
                                               (car x)))
                         ($if (inexact? (car x))
                              ($define! result (* result 1.0))
                              #inert))
                    (apply aux (list* (- count 1) result (cdr x)))))))

      (apply aux (list* (car (get-list-metrics x))
                        #e-infinity
                        x))))

($define! lcm
   ($lambda x

      ($define! gcd
         ($lambda (x y)
            ($if (=? x y)
                 x             ; don't worry here about inexactness
                 ($if (<? x y)
                      (gcd x (- y x))
                      (gcd (- x y) y)))))

      ($define! aux3
         ($lambda (x y)
            (/ (* x y) (gcd x y))))

      ($define! aux2
         ($lambda (result k)
            ($cond ((=? k 0)                 (* k #e+infinity)) ; induce error
                   ((=? k #e+infinity)       (* k result))
                   ((=? k #e-infinity)       (* k result -1))
                   ((=? result #e+infinity)  (* result (abs k)))
                   (#t                       (aux3 result (abs k))))))

      ($define! aux
         ($lambda (count result . x)
            ($if (<=? count 0)
                 result
                 (apply aux (list* (- count 1)
                                   (aux2 result (car x))
                                   (cdr x))))))

      (apply aux (list* (car (get-list-metrics x))
                        1
                        x))))

